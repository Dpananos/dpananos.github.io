{
  "hash": "e6795d26d2a4d3ca3058f18752ba338c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Let's Take About 15% Of The Top There\ndate: 2025-08-10\ncode-fold: true\necho: true\nfig-cap-location: top\ncategories: []\nnumber-sections: false\ndraft: false\ncache: true\n---\n\n\n\nI keep coming back to [A New Look at P Values for Randomized Clinical Trials](https://evidence.nejm.org/doi/full/10.1056/EVIDoa2300003) -- an instant classic paper on RCTs, which could be extended to online experimentation as well.  The authors, who include Gelman and Greenland, take an empirical Bayes approach to infer the joint distribution of z statistics and the Signal to Noise Ratio (SNR, the true effect divided by the standard error) from the Cochrane Database of Systematic Reviews, thereby being able to examine the relationship between, as an example, the exaggeration factor (the amount by which the estimate of the treatment effect over estimates the truth) and the p value.  It is an incredibly well written paper and I highly recommend you read it.\n\nQuoting from the paper directly\n\n>Recall that the z statistic is the estimated effect divided by the standard error (SE) of the estimate. We also wish to consider the signal-to-noise ratio (SNR), which is the true effect divided by the SE of the effect estimate. The SNR cannot be observed directly, but there is a very simple relation between the SNR and the z statistic. Because the estimated effect is equal to the true effect plus an independent normal error term, the z statistic is equal to the SNR plus an independent, standard normal error term.1 Thus, the distribution of the z statistic is the ‚Äúconvolution‚Äù of the distribution of the SNR and the standard normal distribution. The crux of our approach is that we can estimate the distribution of the absolute z statistics across the Cochrane Database and then derive the distribution of the absolute SNRs by ‚Äúdeconvolution,‚Äù that is, by removing the standard normal component. This allows us to study a number of important statistical properties of the RCTs in the Cochrane Database.\n\nThe authors give the weights and standard deviations for the elements of the mixture distribution, and from these we can simulate SNRs from the population of all trails that are exchangeable with those in the database (i.e. trials that could be in the Cochrane Database in the future).  In R...\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(tidyverse)\nrmix = function(n,p,m,s){\n  d=rmultinom(n,1,p)\n  rnorm(n,m%*%d,s%*%d)\n}\n\n# Standard deviation for the snr\ns <- c(0.61, 1.42, 2.16, 5.64)\np <- c(0.32, 0.3, 0.3, 0.07)\nm <- rep(0, 4)\nn <- 1e6\nsnr <- rmix(n, p, m, s)\nz <- rnorm(n, snr, 1)\n```\n:::\n\n\nNow that we have the simulated SNR and z statistics, it is very straight forward to replicate all results from the paper.  As an example, here is how we can re-create figure 2 (the distribution of statistical power across the simulated SNR).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\npower <- pnorm(-1.96 - snr) + 1 - pnorm(1.96-snr)\nhist(power, xlab = 'Power', breaks=40, col = 'white', probability = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nThe paper goes on to make a number of conclusions, including that most RCTs which report a statistically significant treatment effect exaggerate the effect size, sometimes dramatically so (see Figure 3, top left). This exaggeration made me think \"why not just shrink the damn thing then\", and given some of the information in the paper, I think we can come up with a nice little rule of thumb: most RCTs should shrink the treatment effect by about 15%.  Let's examine why.\n\n\nThe mixture distribution for the z statistics is comprised of 4 normal distributions with standard deviation 1.17, 1.74, 2.38, and 5.73, with mixture weights 0.32, 0.3, 0.3, and 0.07.  This means that the standard deviation of the mixture is 2.32.  Let's make a not-too-wrong assumption that the distribution of z values is approximately normal.  Granted, this is demonstrably false -- the distribution has fatter tails, but doing so will allow us to treat this distribution as a prior for future RCTs.  Now, suppose we run an RCT in the future which would be exchangeable with those in the Cochrane database.  Since the prior distribution of z is assumed normal, and conditional on the RCT z is also a normal random variable,  then we can shrink the estimates by leveraging a conjugate normal prior.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\ns_z <- c(1.17, 1.74, 2.38, 5.73)\ns_weighted <- sqrt(weighted.mean(s_z^2, p))\n\nnew_snr <- rmix(n, p, m, s)\nnew_z <- rnorm(n, new_snr, 1)\nshrunken_z <- new_z * 1.0 / (1/s_weighted^2 + 1)\n\nnew_exag <- abs(new_z/new_snr)\nshrunken_exag <- abs(shrunken_z/new_snr)\n```\n:::\n\n\nNote that the z are multiplied by a factor which is approximately 0.843 (round up to 0.85 for a nice number, which is equivalent to a 15% reduction).  Now, let's recreate figure 3 for the shurnken estimates and compare them to the unshrunken estimates\n\n\n::: {.cell}\n\n```{.r .cell-code}\np_values <- 2*pnorm(-abs(new_z))\np_strata <- cut(p_values, c(c(0, 0.001, 0.005, 0.01, 0.05, 0.1), seq(.5, 1, 0.1)))\n\n\ndf_sum <- tibble(\n  p_strata = p_strata, \n  Orignal = new_exag,\n  Shrunken = shrunken_exag\n) %>% \n  pivot_longer(-p_strata, names_to = 'estimate', values_to = 'exag') %>% \n  group_by(p_strata, \n           estimate\n           ) %>%\n  summarise(\n    q25 = quantile(exag, 0.25, na.rm = TRUE),\n    q50 = quantile(exag, 0.50, na.rm = TRUE),\n    q75 = quantile(exag, 0.75, na.rm = TRUE),\n    mn = mean(exag)\n  ) %>%\n  mutate(strata_num = as.numeric(p_strata))\n\n# Plot\ndodge_width <- -0.2\n\nggplot(df_sum, aes(x = strata_num, fill = estimate)) +\n  geom_rect(aes(\n    xmin = strata_num - 0.2 + \n      ifelse(estimate == \"Orignal\", -dodge_width, dodge_width),\n    xmax = strata_num + 0.2 + \n      ifelse(estimate == \"Orignal\", -dodge_width, dodge_width),\n    ymin = q25, ymax = q75\n  ), alpha = 0.7, color='black'\n  ) +\n  geom_segment(aes(\n    x = strata_num - 0.2 + \n      ifelse(estimate == \"Orignal\", -dodge_width, dodge_width),\n    xend = strata_num + 0.2 + \n      ifelse(estimate == \"Orignal\", -dodge_width, dodge_width),\n    y = q50, yend = q50\n  ),\n  size = 1\n  ) +\n  geom_hline(yintercept = 1, color = \"grey50\", size = 2, alpha = 0.5) +\n  scale_x_reverse(\n    breaks = unique(df_sum$strata_num),\n    labels = levels(p_strata),\n    guide = guide_axis(n.dodge = 2)\n  ) +\n  labs(\n    x = \"P Value Strata\",\n    y = \"Exaggeration Quartiles\",\n    fill='Estimate'\n  ) +\n  theme_classic(base_size = 14) +\n  theme(legend.position = 'top') + \n  scale_fill_brewer(palette = \"Set1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nUnsurprisingly, the estimates are shrunk towards an exaggeration factor of 0.0 and results from statistically significant trials have a smaller exaggeration factor.  However, we can do better.  van Zwet (also an author on the paper) published a shrinkage estimator based on these data in [Statsitics in Medicine](https://onlinelibrary.wiley.com/doi/10.1002/sim.9173) in 2021.  His approach was to use $\\mathbb{E}(\\mbox{SNR} \\mid z)$ as the shrunken estimate, and provides some code in that paper from which to estimate the conditional distribution of the SNR given z from the mixture of normals (it is actually quite clever and doesn't require any regression, only some algebra).  I've plotted van Zwet's exaggeration factors below, which are even better than the normal normal conjugate model's!  Unfortunately, the shrinkage van Zwet's shrinkage estimator doesn't have such a simple rule of thumb which could make for a snappy, Letterkenny referencing, blog post ü§∑.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_hat <- map_dbl(new_z, ~{\n  \n  s2 <- s^2\n  q <- p*dnorm(.x,0,sqrt(s2+1))\n  q <- q/sum(q)\n  m <- .x * s2 / (s2+1)\n  sum(q * m)\n})\n\n\nzwet_shrunken_exag <- abs(z_hat / new_snr)\n\n# Assign a numeric index per estimate for dodging\ndf_sum <- tibble(\n  p_strata = p_strata, \n  Orignal = new_exag,\n  Shrunken = shrunken_exag,\n  `van Zwet Shrunken` = zwet_shrunken_exag\n) %>% \n  pivot_longer(-p_strata, names_to = 'estimate', values_to = 'exag') %>% \n  group_by(p_strata, \n           estimate\n           ) %>%\n  summarise(\n    q25 = quantile(exag, 0.25, na.rm = TRUE),\n    q50 = quantile(exag, 0.50, na.rm = TRUE),\n    q75 = quantile(exag, 0.75, na.rm = TRUE),\n    mn = mean(exag)\n  ) %>%\n  mutate(strata_num = as.numeric(p_strata)) %>%\n  group_by(p_strata) %>%\n  mutate(est_index = as.numeric(factor(estimate, \n                                       levels = c(\"van Zwet Shrunken\", \"Shrunken\", \"Orignal\")))) %>%\n  ungroup()\n\nbar_width <- 0.25\n\nggplot(df_sum, aes(x = strata_num, fill = estimate)) +\n  # IQR rectangles\n  geom_rect(aes(\n    xmin = strata_num + (est_index - 2) * bar_width,\n    xmax = strata_num + (est_index - 2) * bar_width + bar_width,\n    ymin = q25, ymax = q75\n  ),\n  colour = \"black\", alpha = 0.7\n  ) +\n  # Median lines\n  geom_segment(aes(\n    x = strata_num + (est_index - 2) * bar_width,\n    xend = strata_num + (est_index - 2) * bar_width + bar_width,\n    y = q50, yend = q50\n  ),\n  size = 1, colour = \"black\"\n  ) +\n  geom_hline(yintercept = 1, color = \"grey50\", size = 1.5, alpha = 0.5) +\n  scale_x_reverse(\n    breaks = unique(df_sum$strata_num),\n    labels = levels(p_strata),\n    guide = guide_axis(n.dodge = 2)\n  ) +\n  labs(\n    x = \"P Value Strata\",\n    y = \"Exaggeration Quartiles\",\n    fill = 'Estimate'\n  ) +\n  theme_classic(base_size = 14) +\n  theme(legend.position = 'top') + \n  scale_fill_brewer(palette = \"Set1\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}