{
  "hash": "f37a489f08c6a1e29abd3857b5ba9f96",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Cleaning Data Patterns\ndate: 2026-02-09\ncode-fold: false\necho: true\nfig-cap-location: top\ncategories: []\nnumber-sections: false\ndraft: false\ncache: true\n---\n\n::: {.cell}\n\n:::\n\n\n\nI still clean data from time to time, and I find myself writing patterns that looks like\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_data %>%\n  mutate(\n    smoking = case_match(str_to_lower(smoking),\n      \"y\" ~ \"Y\",\n      \"n\" ~ \"N\",\n      .default = \"N\"\n    ),\n    hypertension = case_match(str_to_lower(hypertension),\n      \"y\" ~ \"Y\",\n      \"n\" ~ \"N\",\n      .default = \"N\"\n    ),\n    diabetes = case_match(str_to_lower(diabetes),\n      \"y\" ~ \"Y\",\n      \"n\" ~ \"N\",\n      .default = \"N\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n      id smoking hypertension diabetes\n   <int> <chr>   <chr>        <chr>   \n 1     1 Y       Y            N       \n 2     2 N       Y            Y       \n 3     3 Y       N            Y       \n 4     4 N       N            N       \n 5     5 N       N            N       \n 6     6 N       N            N       \n 7     7 N       Y            Y       \n 8     8 Y       N            N       \n 9     9 N       N            N       \n10    10 N       N            N       \n```\n\n\n:::\n:::\n\n\n\nI know the aphorism is \"If you write a piece of code 3 times, write a function\" so I could do\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclean_yn <- function(x){\n  case_match(str_to_lower(x), \n        \"y\" ~ \"Y\",\n        \"n\" ~ \"N\",\n        .default = \"N\"\n             )\n}\n\nraw_data %>%\n  mutate(\n    across(\n      all_of(c(\"smoking\", \"hypertension\", \"diabetes\")),\n    ~clean_yn(.x)\n    ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n      id smoking hypertension diabetes\n   <int> <chr>   <chr>        <chr>   \n 1     1 Y       Y            N       \n 2     2 N       Y            Y       \n 3     3 Y       N            Y       \n 4     4 N       N            N       \n 5     5 N       N            N       \n 6     6 N       N            N       \n 7     7 N       Y            Y       \n 8     8 Y       N            N       \n 9     9 N       N            N       \n10    10 N       N            N       \n```\n\n\n:::\n:::\n\n\nBut I usually have to edit the name of the column too because often `smoking` is actually `Smoking (Yes or No)` (and while `{janitor}` helps it still leaves some cruft on the end of column names).  This makes the first pattern more attractive, despite the repetition.\n\nI asked gemini how it might handle this problem, and I was shown a neat little pattern I want to share.  The mutate-across pattern us actually pretty useful, so let's abstract that into a function and tack on a rename like so\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply_cleaners <- function(data, clean_func, rename_map){\n  data |> \n    mutate(\n      across(all_of(unname(rename_map)), ~clean_func(.x))\n    ) |> \n    rename(all_of(rename_map))\n}\n```\n:::\n\n\nNow, I can specify a list of columns I want to clean with the same function, and the new names I want to use\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncleaning_tasks <- list(\n  rename_map = c('smoking_cleaned' = 'smoking', \n                 'hypertension_cleaned' = 'hypertension',\n                 'diabetes_cleaned' = 'diabetes'),\n  func = clean_yn\n)\n\napply_cleaners(raw_data, cleaning_tasks$func, cleaning_tasks$rename_map)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n      id smoking_cleaned hypertension_cleaned diabetes_cleaned\n   <int> <chr>           <chr>                <chr>           \n 1     1 Y               Y                    N               \n 2     2 N               Y                    Y               \n 3     3 Y               N                    Y               \n 4     4 N               N                    N               \n 5     5 N               N                    N               \n 6     6 N               N                    N               \n 7     7 N               Y                    Y               \n 8     8 Y               N                    N               \n 9     9 N               N                    N               \n10    10 N               N                    N               \n```\n\n\n:::\n:::\n\n\nwhich doesn't seem that cool, unless you realize that what is returned is a tibble, which can be passed through `apply_cleaners` again.  Hence, `reduce` seems like a good tool here\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Needs to be a list of lists \ncleaning_tasks <- list(\n  \"yn_cleaning_tasks\" = list(\n    rename_map = c('smoking_cleaned' = 'smoking', \n                   'hypertension_cleaned' = 'hypertension',\n                   'diabetes_cleaned' = 'diabetes'),\n    func = clean_yn\n  )\n)\n\n\nreduce(cleaning_tasks, function(data, task) {\n  apply_cleaners(data, task$func, task$rename_map)\n}, .init=raw_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 4\n      id smoking_cleaned hypertension_cleaned diabetes_cleaned\n   <int> <chr>           <chr>                <chr>           \n 1     1 Y               Y                    N               \n 2     2 N               Y                    Y               \n 3     3 Y               N                    Y               \n 4     4 N               N                    N               \n 5     5 N               N                    N               \n 6     6 N               N                    N               \n 7     7 N               Y                    Y               \n 8     8 Y               N                    N               \n 9     9 N               N                    N               \n10    10 N               N                    N               \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}